MQ Message queue 消息队列

”一发一存一消费，转发器“





RocketMQ
kafka 
RabbitMQ elang语言写的





队列模型

发布-订阅模型



主要功能

1、削峰填谷：不直接访问服务，缓解服务压力，增加性能

2、不需要立即返回的业务异步处理



eg.

电商交易下单场景，正常交易流程可能涉及创建订单、扣减库存、扣减活动预算，扣减积分等待。

如果每个接口耗时是100ms，那么理论上整个整个下单的链路需要耗时400ms。

链路太长影响接口性能；分布式事务的问题难处理

像扣减预算和积分对实时一致性要求没那么高，可以通过mq异步处理。

异步带来的不一致问题，通过job去重试保证接口调用成功。

有了mq后，链路就简单了，同时异步发送消息整体系统抗压能力上升了



使用的什么mq？基于什么做的选型？

主流的mq有，kafka、rabbitmq、rocketmq、activemq

1、由于系统的qps压力较大，性能是首要考虑元素

2、开发语言，java，方便二次开发

3、高并发的业务场景，支持分布式架构的设计

4、功能全面，不用的业务场景，可能会用到顺序消息、事务消息等

5、社区活跃度、文档全面性，云服务支持

6、项目情况？项目周期、人员、用户量、架构设计、是否老项目

7、公司情况？人员是否充足，现有人员技术栈情况，技术栈实力

8、用途？日志、解耦、异步处理

所以选了rocketMQ



异步发送，消息可靠性怎么保证？

消息丢失发生在3个方面：生产者丢失；mq本身丢失；消费者丢失

一、生产者丢失：

程序发送失败抛异常了没有重试处理；发送过程成功但是过程中网络闪断mq没收到，消息丢失了

异步发送分两种方式：异步有回调；异步无回调

1、下单后先保存本地数据和mq消息表，这个时候消息状态是发送中；如果本地事务失败，那么下单失败，事务回滚

2、下单成功，直接返回客户端成功，异步发送mq消息

3、mq回调通知消息发送结构，对于更新数据库mq发送状态

4、job轮询超过一定时间，还未发送成功的消息去重试

5、在监控平台配置或job程序处理超过一定次数一直发送不成功的消息，告警，人工介入

一般来说对大多数场景异步回调就可以

二、mq本身丢失

三、消息者丢失：

消费者返回ack确认



重复消费怎么办？

可能由于网络原因、服务重启导致消息消费未记录，造成重复消费

一般处理方式就是，保证接口设计的幂等性，主旨通过唯一标识判断是否存在。

1、redis缓存使用，唯一性token保存redis，每次消费后删除token

2、唯一主键判断，数据库判断是否存在该主键记录，存在则更新；不存在就插入



确保消息被消费？

